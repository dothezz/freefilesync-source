<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>zen::Xml: dom.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  <td id="projectlogo"><img alt="Logo" src="zenXml.png"/></td>
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">zen::Xml
   
   </div>
   <div id="projectbrief">Simple C++  XML Processing</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">dom.h</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// **************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment">// * This file is part of the zen::Xml project. It is distributed under the *</span>
<a name="l00003"></a>00003 <span class="comment">// * Boost Software License: http://www.boost.org/LICENSE_1_0.txt           *</span>
<a name="l00004"></a>00004 <span class="comment">// * Copyright (C) Zenju (zenju AT gmx DOT de) - All Rights Reserved        *</span>
<a name="l00005"></a>00005 <span class="comment">// **************************************************************************</span>
<a name="l00006"></a>00006 
<a name="l00007"></a>00007 <span class="preprocessor">#ifndef ZEN_XML_DOM_HEADER_82085720723894567204564256</span>
<a name="l00008"></a>00008 <span class="preprocessor"></span><span class="preprocessor">#define ZEN_XML_DOM_HEADER_82085720723894567204564256</span>
<a name="l00009"></a>00009 <span class="preprocessor"></span>
<a name="l00010"></a>00010 <span class="preprocessor">#include &lt;string&gt;</span>
<a name="l00011"></a>00011 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include &lt;memory&gt;</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include &lt;map&gt;</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include &quot;cvrt_text.h&quot;</span> <span class="comment">//&quot;readText/writeText&quot;</span>
<a name="l00015"></a>00015 
<a name="l00016"></a>00016 <span class="keyword">namespace </span>zen
<a name="l00017"></a>00017 {
<a name="l00018"></a>00018 <span class="keyword">class </span>XmlDoc;
<a name="l00019"></a>00019 
<a name="l00021"></a><a class="code" href="classzen_1_1_xml_element.html">00021</a> <span class="keyword">class </span><a class="code" href="classzen_1_1_xml_element.html" title="An XML element.">XmlElement</a>
<a name="l00022"></a>00022 {
<a name="l00023"></a>00023     <span class="keyword">struct </span>PrivateConstruction {};
<a name="l00024"></a>00024 <span class="keyword">public</span>:
<a name="l00025"></a>00025     <span class="comment">//Construct an empty XML element</span>
<a name="l00026"></a>00026     <span class="comment">//This constructor should be private, however std::make_shared() requires public access</span>
<a name="l00027"></a>00027     <span class="comment">//Therefore at least prevent users from calling it via private dummy type PrivateConstruction</span>
<a name="l00028"></a>00028     <span class="keyword">template</span> &lt;<span class="keyword">class</span> String&gt;
<a name="l00029"></a>00029     <a class="code" href="classzen_1_1_xml_element.html" title="An XML element.">XmlElement</a>(<span class="keyword">const</span> String&amp; name, <a class="code" href="classzen_1_1_xml_element.html" title="An XML element.">XmlElement</a>* parentElement, PrivateConstruction) : name_(utfCvrtTo&lt;std::string&gt;(name)), parent_(parentElement) {}
<a name="l00030"></a>00030 
<a name="l00032"></a>00032 
<a name="l00036"></a>00036     <span class="keyword">template</span> &lt;<span class="keyword">class</span> String&gt;
<a name="l00037"></a><a class="code" href="classzen_1_1_xml_element.html#a7c911eb06a59c864197b1a4098728e50">00037</a>     String <a class="code" href="classzen_1_1_xml_element.html#a7c911eb06a59c864197b1a4098728e50" title="Retrieve the name of this XML element.">getNameAs</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> utfCvrtTo&lt;String&gt;(name_); }
<a name="l00038"></a>00038 
<a name="l00040"></a>00040 
<a name="l00044"></a>00044     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00045"></a><a class="code" href="classzen_1_1_xml_element.html#a5ac9d586a5668c2c64e3c06c6203b070">00045</a>     <span class="keywordtype">bool</span> <a class="code" href="classzen_1_1_xml_element.html#a5ac9d586a5668c2c64e3c06c6203b070" title="Get the value of this element as a user type.">getValue</a>(T&amp; value)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="namespacezen.html#a2bdcecfe7435ef11cedbce47d4e72ee1" title="Convert XML element to structured user data.">readStruc</a>(*<span class="keyword">this</span>, value); }
<a name="l00046"></a>00046 
<a name="l00048"></a>00048 
<a name="l00051"></a>00051     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00052"></a><a class="code" href="classzen_1_1_xml_element.html#aaf3a26f6199fc88cce7d9d911ba21b01">00052</a>     <span class="keywordtype">void</span> <a class="code" href="classzen_1_1_xml_element.html#aaf3a26f6199fc88cce7d9d911ba21b01" title="Set the value of this element.">setValue</a>(<span class="keyword">const</span> T&amp; value) { <a class="code" href="namespacezen.html#a29ddb823fe0a195f19a64448881b8bf6" title="Convert structured user data into an XML element.">writeStruc</a>(value, *<span class="keyword">this</span>); }
<a name="l00053"></a>00053 
<a name="l00055"></a>00055 
<a name="l00062"></a>00062     <span class="keyword">template</span> &lt;<span class="keyword">class</span> String, <span class="keyword">class</span> T&gt;
<a name="l00063"></a><a class="code" href="classzen_1_1_xml_element.html#af90ac6f435b03ba37cf47ee188c58887">00063</a>     <span class="keywordtype">bool</span> <a class="code" href="classzen_1_1_xml_element.html#af90ac6f435b03ba37cf47ee188c58887" title="Retrieve an attribute by name.">getAttribute</a>(<span class="keyword">const</span> String&amp; name, T&amp; value)<span class="keyword"> const</span>
<a name="l00064"></a>00064 <span class="keyword">    </span>{
<a name="l00065"></a>00065         <span class="keyword">auto</span> it = attributes.find(utfCvrtTo&lt;std::string&gt;(name));
<a name="l00066"></a>00066         <span class="keywordflow">return</span> it == attributes.end() ? <span class="keyword">false</span> : <a class="code" href="namespacezen.html#acaf85ab94b61882f957afcd355386bff" title="Convert text to user data - used by XML elements and attributes.">readText</a>(it-&gt;second, value);
<a name="l00067"></a>00067     }
<a name="l00068"></a>00068 
<a name="l00070"></a>00070 
<a name="l00076"></a>00076     <span class="keyword">template</span> &lt;<span class="keyword">class</span> String, <span class="keyword">class</span> T&gt;
<a name="l00077"></a><a class="code" href="classzen_1_1_xml_element.html#a211a6f037c22a54d3facb7a8347a8421">00077</a>     <span class="keywordtype">void</span> <a class="code" href="classzen_1_1_xml_element.html#a211a6f037c22a54d3facb7a8347a8421" title="Create or update an XML attribute.">setAttribute</a>(<span class="keyword">const</span> String&amp; name, <span class="keyword">const</span> T&amp; value)
<a name="l00078"></a>00078     {
<a name="l00079"></a>00079         std::string attrValue;
<a name="l00080"></a>00080         <a class="code" href="namespacezen.html#a2ce2998296871fc2f4718ceceb22a23f" title="Convert user data into text - used by XML elements and attributes.">writeText</a>(value, attrValue);
<a name="l00081"></a>00081         attributes[utfCvrtTo&lt;std::string&gt;(name)] = attrValue;
<a name="l00082"></a>00082     }
<a name="l00083"></a>00083 
<a name="l00085"></a>00085 
<a name="l00088"></a>00088     <span class="keyword">template</span> &lt;<span class="keyword">class</span> String&gt;
<a name="l00089"></a><a class="code" href="classzen_1_1_xml_element.html#ad9c2ce2e55294c8110825988595e3934">00089</a>     <span class="keywordtype">void</span> <a class="code" href="classzen_1_1_xml_element.html#ad9c2ce2e55294c8110825988595e3934" title="Remove the attribute with the given name.">removeAttribute</a>(<span class="keyword">const</span> String&amp; name) { attributes.erase(utfCvrtTo&lt;std::string&gt;(name)); }
<a name="l00090"></a>00090 
<a name="l00092"></a>00092 
<a name="l00096"></a>00096     <span class="keyword">template</span> &lt;<span class="keyword">class</span> String&gt;
<a name="l00097"></a><a class="code" href="classzen_1_1_xml_element.html#a653caffa6fad89db7d14f67f987ad0f9">00097</a>     <a class="code" href="classzen_1_1_xml_element.html" title="An XML element.">XmlElement</a>&amp; <a class="code" href="classzen_1_1_xml_element.html#a653caffa6fad89db7d14f67f987ad0f9" title="Create a new child element and return a reference to it.">addChild</a>(<span class="keyword">const</span> String&amp; name)
<a name="l00098"></a>00098     {
<a name="l00099"></a>00099         std::string utf8Name = utfCvrtTo&lt;std::string&gt;(name);
<a name="l00100"></a>00100         <span class="keyword">auto</span> newElement = std::make_shared&lt;XmlElement&gt;(utf8Name, <span class="keyword">this</span>, PrivateConstruction());
<a name="l00101"></a>00101         childElements.push_back(newElement);
<a name="l00102"></a>00102         childElementsSorted.insert(std::make_pair(utf8Name, newElement));
<a name="l00103"></a>00103         <span class="keywordflow">return</span> *newElement;
<a name="l00104"></a>00104     }
<a name="l00105"></a>00105 
<a name="l00107"></a>00107 
<a name="l00112"></a>00112     <span class="keyword">template</span> &lt;<span class="keyword">class</span> String&gt;
<a name="l00113"></a><a class="code" href="classzen_1_1_xml_element.html#a3ab82b1720460487f4afabcd115d0c7e">00113</a>     <span class="keyword">const</span> <a class="code" href="classzen_1_1_xml_element.html" title="An XML element.">XmlElement</a>* <a class="code" href="classzen_1_1_xml_element.html#a3ab82b1720460487f4afabcd115d0c7e" title="Retrieve a child element with the given name.">getChild</a>(<span class="keyword">const</span> String&amp; name)<span class="keyword"> const</span>
<a name="l00114"></a>00114 <span class="keyword">    </span>{
<a name="l00115"></a>00115         <span class="keyword">auto</span> it = childElementsSorted.find(utfCvrtTo&lt;std::string&gt;(name));
<a name="l00116"></a>00116         <span class="keywordflow">return</span> it == childElementsSorted.end() ? <span class="keyword">nullptr</span> : &amp;*(it-&gt;second);
<a name="l00117"></a>00117     }
<a name="l00118"></a>00118 
<a name="l00120"></a>00120     <span class="keyword">template</span> &lt;<span class="keyword">class</span> String&gt;
<a name="l00121"></a><a class="code" href="classzen_1_1_xml_element.html#a5d672e8ccc7592442ab927bb267af658">00121</a>     <a class="code" href="classzen_1_1_xml_element.html" title="An XML element.">XmlElement</a>* <a class="code" href="classzen_1_1_xml_element.html#a3ab82b1720460487f4afabcd115d0c7e" title="Retrieve a child element with the given name.">getChild</a>(<span class="keyword">const</span> String&amp; name)
<a name="l00122"></a>00122     {
<a name="l00123"></a>00123         <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span><a class="code" href="classzen_1_1_xml_element.html" title="An XML element.">XmlElement</a>*<span class="keyword">&gt;</span>(<span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code" href="classzen_1_1_xml_element.html" title="An XML element.">XmlElement</a>*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;<a class="code" href="classzen_1_1_xml_element.html#a3ab82b1720460487f4afabcd115d0c7e" title="Retrieve a child element with the given name.">getChild</a>(name));
<a name="l00124"></a>00124     }
<a name="l00125"></a>00125 
<a name="l00126"></a>00126     <span class="keyword">template</span> &lt; <span class="keyword">class </span>IterTy,     <span class="comment">//underlying iterator type</span>
<a name="l00127"></a>00127              <span class="keyword">class </span>T,            <span class="comment">//target object type</span>
<a name="l00128"></a>00128              <span class="keyword">class </span>AccessPolicy &gt; <span class="comment">//access policy: see AccessPtrMap</span>
<a name="l00129"></a>00129     <span class="keyword">class </span>PtrIter : <span class="keyword">public</span> std::iterator&lt;std::input_iterator_tag, T&gt;, <span class="keyword">private</span> AccessPolicy <span class="comment">//get rid of shared_ptr indirection</span>
<a name="l00130"></a>00130     {
<a name="l00131"></a>00131     <span class="keyword">public</span>:
<a name="l00132"></a>00132         PtrIter(IterTy it) : it_(it) {}
<a name="l00133"></a>00133         PtrIter(<span class="keyword">const</span> PtrIter&amp; other) : it_(other.it_) {}
<a name="l00134"></a>00134         PtrIter&amp; operator++() { ++it_; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00135"></a>00135         PtrIter operator++(<span class="keywordtype">int</span>) { PtrIter tmp(*<span class="keyword">this</span>); operator++(); <span class="keywordflow">return</span> tmp; }
<a name="l00136"></a>00136         <span class="keyword">inline</span> <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> PtrIter&amp; lhs, <span class="keyword">const</span> PtrIter&amp; rhs) { <span class="keywordflow">return</span> lhs.it_ == rhs.it_; }
<a name="l00137"></a>00137         <span class="keyword">inline</span> <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> PtrIter&amp; lhs, <span class="keyword">const</span> PtrIter&amp; rhs) { <span class="keywordflow">return</span> !(lhs == rhs); }
<a name="l00138"></a>00138         T&amp; operator* () { <span class="keywordflow">return</span>  AccessPolicy::template objectRef&lt;T&gt;(it_); }
<a name="l00139"></a>00139         T* operator-&gt;() { <span class="keywordflow">return</span> &amp;AccessPolicy::template objectRef&lt;T&gt;(it_); }
<a name="l00140"></a>00140     <span class="keyword">private</span>:
<a name="l00141"></a>00141         IterTy it_;
<a name="l00142"></a>00142     };
<a name="l00143"></a>00143 
<a name="l00144"></a>00144     <span class="keyword">struct </span>AccessPtrMap
<a name="l00145"></a>00145     {
<a name="l00146"></a>00146         <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> IterTy&gt;
<a name="l00147"></a>00147         T&amp; objectRef(<span class="keyword">const</span> IterTy&amp; it) { <span class="keywordflow">return</span> *(it-&gt;second); }
<a name="l00148"></a>00148     };
<a name="l00149"></a>00149 
<a name="l00150"></a>00150     <span class="keyword">typedef</span> PtrIter&lt;std::multimap&lt;std::string, std::shared_ptr&lt;XmlElement&gt;&gt;::iterator, XmlElement, AccessPtrMap&gt; ChildIter2;
<a name="l00151"></a>00151     <span class="keyword">typedef</span> PtrIter&lt;std::multimap&lt;std::string, std::shared_ptr&lt;XmlElement&gt;&gt;::const_iterator, <span class="keyword">const</span> XmlElement, AccessPtrMap&gt; ChildIterConst2;
<a name="l00152"></a>00152 
<a name="l00154"></a>00154 
<a name="l00163"></a>00163     <span class="keyword">template</span> &lt;<span class="keyword">class</span> String&gt;
<a name="l00164"></a><a class="code" href="classzen_1_1_xml_element.html#a2640b438c4984f5eeb8760d82d73c5b8">00164</a>     std::pair&lt;ChildIterConst2, ChildIterConst2&gt; <a class="code" href="classzen_1_1_xml_element.html#a2640b438c4984f5eeb8760d82d73c5b8" title="Access all child elements with the given name via STL iterators.">getChildren</a>(<span class="keyword">const</span> String&amp; name)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> childElementsSorted.equal_range(utfCvrtTo&lt;std::string&gt;(name)); }
<a name="l00165"></a>00165 
<a name="l00167"></a>00167     <span class="keyword">template</span> &lt;<span class="keyword">class</span> String&gt;
<a name="l00168"></a><a class="code" href="classzen_1_1_xml_element.html#ae209dac9655bc36121abb87688ece41d">00168</a>     std::pair&lt;ChildIter2, ChildIter2&gt; <a class="code" href="classzen_1_1_xml_element.html#ae209dac9655bc36121abb87688ece41d">getChildren</a>(<span class="keyword">const</span> String&amp; name) { <span class="keywordflow">return</span> childElementsSorted.equal_range(utfCvrtTo&lt;std::string&gt;(name)); }
<a name="l00169"></a>00169 
<a name="l00170"></a>00170     <span class="keyword">struct </span>AccessPtrVec
<a name="l00171"></a>00171     {
<a name="l00172"></a>00172         <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> IterTy&gt;
<a name="l00173"></a>00173         T&amp; objectRef(<span class="keyword">const</span> IterTy&amp; it) { <span class="keywordflow">return</span> **it; }
<a name="l00174"></a>00174     };
<a name="l00175"></a>00175 
<a name="l00176"></a>00176     <span class="keyword">typedef</span> PtrIter&lt;std::vector&lt;std::shared_ptr&lt;XmlElement&gt;&gt;::iterator, XmlElement, AccessPtrVec&gt; ChildIter;
<a name="l00177"></a>00177     <span class="keyword">typedef</span> PtrIter&lt;std::vector&lt;std::shared_ptr&lt;XmlElement&gt;&gt;::const_iterator, <span class="keyword">const</span> XmlElement, AccessPtrVec&gt; ChildIterConst;
<a name="l00178"></a>00178 
<a name="l00180"></a>00180 
<a name="l00188"></a><a class="code" href="classzen_1_1_xml_element.html#a55a6d1849490d82ae900cd9b923908f2">00188</a>     std::pair&lt;ChildIterConst, ChildIterConst&gt; <a class="code" href="classzen_1_1_xml_element.html#a55a6d1849490d82ae900cd9b923908f2" title="Access all child elements sequentially via STL iterators.">getChildren</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> std::make_pair(childElements.begin(), childElements.end()); }
<a name="l00189"></a>00189 
<a name="l00191"></a><a class="code" href="classzen_1_1_xml_element.html#ac59268177d162931f937b6a7f235ad96">00191</a>     std::pair&lt;ChildIter, ChildIter&gt; <a class="code" href="classzen_1_1_xml_element.html#ac59268177d162931f937b6a7f235ad96">getChildren</a>() { <span class="keywordflow">return</span> std::make_pair(childElements.begin(), childElements.end()); }
<a name="l00192"></a>00192 
<a name="l00194"></a><a class="code" href="classzen_1_1_xml_element.html#a4af309f59ef09f46a559f1f0e1eac6c1">00194</a>     <a class="code" href="classzen_1_1_xml_element.html" title="An XML element.">XmlElement</a>* <a class="code" href="classzen_1_1_xml_element.html#a4af309f59ef09f46a559f1f0e1eac6c1" title="Get parent XML element, may be nullptr for root element.">parent</a>() { <span class="keywordflow">return</span> parent_; };
<a name="l00196"></a><a class="code" href="classzen_1_1_xml_element.html#a7ba1f26be5629f89ba7648d658f7058c">00196</a>     <span class="keyword">const</span> <a class="code" href="classzen_1_1_xml_element.html" title="An XML element.">XmlElement</a>* <a class="code" href="classzen_1_1_xml_element.html#a7ba1f26be5629f89ba7648d658f7058c" title="Get parent XML element, may be nullptr for root element.">parent</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> parent_; };
<a name="l00197"></a>00197 
<a name="l00198"></a>00198 
<a name="l00199"></a>00199     <span class="keyword">typedef</span> std::map&lt;std::string, std::string&gt;::const_iterator AttrIter;
<a name="l00200"></a>00200 
<a name="l00201"></a>00201     <span class="comment">/* -&gt; disabled documentation extraction</span>
<a name="l00202"></a>00202 <span class="comment">      \brief Get all attributes associated with the element.</span>
<a name="l00203"></a>00203 <span class="comment">      \code</span>
<a name="l00204"></a>00204 <span class="comment">        auto iterPair = elem.getAttributes();</span>
<a name="l00205"></a>00205 <span class="comment">        for (auto it = iterPair.first; it != iterPair.second; ++it)</span>
<a name="l00206"></a>00206 <span class="comment">           std::cout &lt;&lt; &quot;name: &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value: &quot; &lt;&lt; it-&gt;second &lt;&lt; &quot;\n&quot;;</span>
<a name="l00207"></a>00207 <span class="comment">      \endcode</span>
<a name="l00208"></a>00208 <span class="comment">      \return A pair of STL begin/end iterators to access all attributes sequentially as a list of name/value pairs of std::string.</span>
<a name="l00209"></a>00209 <span class="comment">    */</span>
<a name="l00210"></a>00210     std::pair&lt;AttrIter, AttrIter&gt; getAttributes()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> std::make_pair(attributes.begin(), attributes.end()); }
<a name="l00211"></a>00211 
<a name="l00212"></a>00212     <span class="comment">//Transactionally swap two elements.  -&gt; disabled documentation extraction</span>
<a name="l00213"></a>00213     <span class="keywordtype">void</span> swap(XmlElement&amp; other)
<a name="l00214"></a>00214     {
<a name="l00215"></a>00215         name_     .swap(other.name_);
<a name="l00216"></a>00216         value_    .swap(other.value_);
<a name="l00217"></a>00217         attributes.swap(other.attributes);
<a name="l00218"></a>00218         childElements.swap(other.childElements);
<a name="l00219"></a>00219         childElementsSorted.swap(other.childElementsSorted);
<a name="l00220"></a>00220         <span class="comment">//std::swap(parent_, other.parent_); -&gt; parent is physical location; update children&#39;s parent reference instead:</span>
<a name="l00221"></a>00221         std::for_each(      childElements.begin(),       childElements.end(), [&amp;](<span class="keyword">const</span> std::shared_ptr&lt;XmlElement&gt;&amp; child) { child-&gt;parent_ = <span class="keyword">this</span>;   });
<a name="l00222"></a>00222         std::for_each(other.childElements.begin(), other.childElements.end(), [&amp;](<span class="keyword">const</span> std::shared_ptr&lt;XmlElement&gt;&amp; child) { child-&gt;parent_ = &amp;other; });
<a name="l00223"></a>00223     }
<a name="l00224"></a>00224 
<a name="l00225"></a>00225 <span class="keyword">private</span>:
<a name="l00226"></a>00226     <span class="keyword">friend</span> <span class="keyword">class </span>XmlDoc;
<a name="l00227"></a>00227 
<a name="l00228"></a>00228     XmlElement(<span class="keyword">const</span> XmlElement&amp;);            <span class="comment">//not implemented</span>
<a name="l00229"></a>00229     XmlElement&amp; operator=(<span class="keyword">const</span> XmlElement&amp;); <span class="comment">//</span>
<a name="l00230"></a>00230 
<a name="l00231"></a>00231     std::string name_;
<a name="l00232"></a>00232     std::string value_;
<a name="l00233"></a>00233     std::map&lt;std::string, std::string&gt; attributes;
<a name="l00234"></a>00234     std::vector&lt;std::shared_ptr&lt;XmlElement&gt;&gt;                childElements;       <span class="comment">//all child elements in order of creation</span>
<a name="l00235"></a>00235     std::multimap&lt;std::string, std::shared_ptr&lt;XmlElement&gt;&gt; childElementsSorted; <span class="comment">//alternate key: sorted by element name</span>
<a name="l00236"></a>00236     XmlElement* parent_;
<a name="l00237"></a>00237 };
<a name="l00238"></a>00238 
<a name="l00239"></a>00239 
<a name="l00240"></a>00240 <span class="comment">//XmlElement::setValue&lt;T&gt;() calls zen::writeStruc() which calls XmlElement::setValue() ... =&gt; these two specializations end the circle</span>
<a name="l00241"></a>00241 <span class="keyword">template</span> &lt;&gt; <span class="keyword">inline</span>
<a name="l00242"></a>00242 <span class="keywordtype">void</span> <a class="code" href="classzen_1_1_xml_element.html#aaf3a26f6199fc88cce7d9d911ba21b01" title="Set the value of this element.">XmlElement::setValue</a>(<span class="keyword">const</span> std::string&amp; value) { value_ = value; }
<a name="l00243"></a>00243 
<a name="l00244"></a>00244 <span class="keyword">template</span> &lt;&gt; <span class="keyword">inline</span>
<a name="l00245"></a>00245 <span class="keywordtype">bool</span> <a class="code" href="classzen_1_1_xml_element.html#a5ac9d586a5668c2c64e3c06c6203b070" title="Get the value of this element as a user type.">XmlElement::getValue</a>(std::string&amp; value)<span class="keyword"> const </span>{ value = value_; <span class="keywordflow">return</span> <span class="keyword">true</span>; }
<a name="l00246"></a>00246 
<a name="l00247"></a>00247 
<a name="l00249"></a><a class="code" href="classzen_1_1_xml_doc.html">00249</a> <span class="keyword">class </span><a class="code" href="classzen_1_1_xml_doc.html" title="The complete XML document.">XmlDoc</a>
<a name="l00250"></a>00250 {
<a name="l00251"></a>00251 <span class="keyword">public</span>:
<a name="l00253"></a><a class="code" href="classzen_1_1_xml_doc.html#adbed9c31066d456a9cc8c610f15670ed">00253</a>     <a class="code" href="classzen_1_1_xml_doc.html#adbed9c31066d456a9cc8c610f15670ed" title="Default constructor setting up an empty XML document with a standard declaration: &lt;...">XmlDoc</a>() : version_(<span class="stringliteral">&quot;1.0&quot;</span>), encoding_(<span class="stringliteral">&quot;UTF-8&quot;</span>), rootElement(<span class="stringliteral">&quot;Root&quot;</span>, nullptr, <a class="code" href="classzen_1_1_xml_element.html" title="An XML element.">XmlElement</a>::PrivateConstruction()) {}
<a name="l00254"></a>00254 
<a name="l00255"></a>00255     <span class="comment">//Setup an empty XML document</span>
<a name="l00260"></a>00260 <span class="comment"></span>    <span class="keyword">template</span> &lt;<span class="keyword">class</span> String&gt;
<a name="l00261"></a><a class="code" href="classzen_1_1_xml_doc.html#a74ff8434848672fe6483845d04c082df">00261</a>     <a class="code" href="classzen_1_1_xml_doc.html#a74ff8434848672fe6483845d04c082df">XmlDoc</a>(String rootName) : version_(<span class="stringliteral">&quot;1.0&quot;</span>), encoding_(<span class="stringliteral">&quot;UTF-8&quot;</span>), rootElement(rootName, nullptr, <a class="code" href="classzen_1_1_xml_element.html" title="An XML element.">XmlElement</a>::PrivateConstruction()) {}
<a name="l00262"></a>00262 
<a name="l00264"></a><a class="code" href="classzen_1_1_xml_doc.html#ad4a9594d93885fc1a12db28e8246648d">00264</a>     <span class="keyword">const</span> <a class="code" href="classzen_1_1_xml_element.html" title="An XML element.">XmlElement</a>&amp; <a class="code" href="classzen_1_1_xml_doc.html#ad4a9594d93885fc1a12db28e8246648d" title="Get a const reference to the document&#39;s root element.">root</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> rootElement; }
<a name="l00266"></a><a class="code" href="classzen_1_1_xml_doc.html#a094e156f9d265443e52a527638e88a1e">00266</a>     <a class="code" href="classzen_1_1_xml_element.html" title="An XML element.">XmlElement</a>&amp; <a class="code" href="classzen_1_1_xml_doc.html#a094e156f9d265443e52a527638e88a1e" title="Get a reference to the document&#39;s root element.">root</a>() { <span class="keywordflow">return</span> rootElement; }
<a name="l00267"></a>00267 
<a name="l00269"></a>00269 
<a name="l00272"></a>00272     <span class="keyword">template</span> &lt;<span class="keyword">class</span> String&gt;
<a name="l00273"></a><a class="code" href="classzen_1_1_xml_doc.html#a7f93dcdc00cdc8d98926cf8e47161665">00273</a>     String <a class="code" href="classzen_1_1_xml_doc.html#a7f93dcdc00cdc8d98926cf8e47161665" title="Get the version used in the XML declaration.">getVersionAs</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> utfCvrtTo&lt;String&gt;(version_); }
<a name="l00274"></a>00274 
<a name="l00276"></a>00276 
<a name="l00279"></a>00279     <span class="keyword">template</span> &lt;<span class="keyword">class</span> String&gt;
<a name="l00280"></a><a class="code" href="classzen_1_1_xml_doc.html#ab45914339c476e1da35746f5e00dbc64">00280</a>     <span class="keywordtype">void</span> <a class="code" href="classzen_1_1_xml_doc.html#ab45914339c476e1da35746f5e00dbc64" title="Set the version used in the XML declaration.">setVersion</a>(<span class="keyword">const</span> String&amp; version) { version_ = utfCvrtTo&lt;std::string&gt;(version); }
<a name="l00281"></a>00281 
<a name="l00283"></a>00283 
<a name="l00286"></a>00286     <span class="keyword">template</span> &lt;<span class="keyword">class</span> String&gt;
<a name="l00287"></a><a class="code" href="classzen_1_1_xml_doc.html#a64ece4a1f3f8c802192b8f31506535da">00287</a>     String <a class="code" href="classzen_1_1_xml_doc.html#a64ece4a1f3f8c802192b8f31506535da" title="Get the encoding used in the XML declaration.">getEncodingAs</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> utfCvrtTo&lt;String&gt;(encoding_); }
<a name="l00288"></a>00288 
<a name="l00290"></a>00290 
<a name="l00293"></a>00293     <span class="keyword">template</span> &lt;<span class="keyword">class</span> String&gt;
<a name="l00294"></a><a class="code" href="classzen_1_1_xml_doc.html#a2ae30bca2f490479f58c272148935a62">00294</a>     <span class="keywordtype">void</span> <a class="code" href="classzen_1_1_xml_doc.html#a2ae30bca2f490479f58c272148935a62" title="Set the encoding used in the XML declaration.">setEncoding</a>(<span class="keyword">const</span> String&amp; encoding) { encoding_ = utfCvrtTo&lt;std::string&gt;(encoding); }
<a name="l00295"></a>00295 
<a name="l00297"></a>00297 
<a name="l00300"></a>00300     <span class="keyword">template</span> &lt;<span class="keyword">class</span> String&gt;
<a name="l00301"></a><a class="code" href="classzen_1_1_xml_doc.html#ac1bfb9776852dc8195b9ffb4f65452e4">00301</a>     String <a class="code" href="classzen_1_1_xml_doc.html#ac1bfb9776852dc8195b9ffb4f65452e4" title="Get the standalone string used in the XML declaration.">getStandaloneAs</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> utfCvrtTo&lt;String&gt;(standalone_); }
<a name="l00302"></a>00302 
<a name="l00304"></a>00304 
<a name="l00307"></a>00307     <span class="keyword">template</span> &lt;<span class="keyword">class</span> String&gt;
<a name="l00308"></a><a class="code" href="classzen_1_1_xml_doc.html#a4c92f9b8c1bb47247b827d89794590d4">00308</a>     <span class="keywordtype">void</span> <a class="code" href="classzen_1_1_xml_doc.html#a4c92f9b8c1bb47247b827d89794590d4" title="Set the standalone string used in the XML declaration.">setStandalone</a>(<span class="keyword">const</span> String&amp; standalone) { standalone_ = utfCvrtTo&lt;std::string&gt;(standalone); }
<a name="l00309"></a>00309 
<a name="l00310"></a>00310 <span class="keyword">private</span>:
<a name="l00311"></a>00311     <a class="code" href="classzen_1_1_xml_doc.html#adbed9c31066d456a9cc8c610f15670ed" title="Default constructor setting up an empty XML document with a standard declaration: &lt;...">XmlDoc</a>(<span class="keyword">const</span> <a class="code" href="classzen_1_1_xml_doc.html" title="The complete XML document.">XmlDoc</a>&amp;);        <span class="comment">//not implemented, thanks to XmlElement::parent_</span>
<a name="l00312"></a>00312     <a class="code" href="classzen_1_1_xml_doc.html" title="The complete XML document.">XmlDoc</a>&amp; operator=(<span class="keyword">const</span> <a class="code" href="classzen_1_1_xml_doc.html" title="The complete XML document.">XmlDoc</a>&amp;); <span class="comment">//</span>
<a name="l00313"></a>00313 
<a name="l00314"></a>00314     std::string version_;
<a name="l00315"></a>00315     std::string encoding_;
<a name="l00316"></a>00316     std::string standalone_;
<a name="l00317"></a>00317 
<a name="l00318"></a>00318     <a class="code" href="classzen_1_1_xml_element.html" title="An XML element.">XmlElement</a> rootElement;
<a name="l00319"></a>00319 };
<a name="l00320"></a>00320 
<a name="l00321"></a>00321 }
<a name="l00322"></a>00322 
<a name="l00323"></a>00323 <span class="preprocessor">#endif //ZEN_XML_DOM_HEADER_82085720723894567204564256</span>
</pre></div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.0
</small></address>

</body>
</html>
